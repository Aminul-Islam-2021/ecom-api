import slugify from "slugify";

import {
  deleteMultipleImages,
  uploadMultipleImages,
  uploadSingleImage,
} from "../handlers/imageHandler.js";
import { Category, SubCategory } from "../models/categoryModel.js";
import { Product } from "../models/productModel.js";
import ApiFeatures from "../utils/apiFeatures.js";
import { cleanUpFiles } from "../config/multerConfig.js";

// Name : Create product
// Route : http://localhost:8000/product
// Method : POST
// Access : Private
export const createProductController = async (req, res) => {
  try {
    const {
      title,
      description,
      price,
      discount,
      brand,
      category,
      subcategory,
      isFeatured,
    } = req.body;

    // Validate required fields
    if (
      !title ||
      !description ||
      !price ||
      !brand ||
      !category ||
      !subcategory
    ) {
      return res
        .status(400)
        .json({ error: "Please provide all required fields" });
    }

    // Check if product title already exists
    const existName = await Product.findOne({ title });
    if (existName) {
      return res.status(404).json("Product title already exists");
    }

    // Generate slug
    const slug = slugify(title, { lower: true, strict: true });

    // Validate category and subcategory
    const categoryExists = await Category.findById(category);
    const subcategoryExists = await SubCategory.findById(subcategory);
    if (!categoryExists || !subcategoryExists) {
      return res.status(400).json({ error: "Invalid category or subcategory" });
    }

    // Calculate discounted price
    const discountedPrice = discount ? price - (price * discount) / 100 : price;

    // Upload main product images
    let mainImages = [];
    if (req.files && req.files["images"]) {
      mainImages = await uploadMultipleImages(req.files["images"]);
    }

    // Handle variants
    let processedVariants = [];
    if (req.body.variants) {
      try {
        const variants = JSON.parse(req.body.variants);

        processedVariants = await Promise.all(
          variants.map(async (variant, index) => {
            let colorImage = null;

            // Handle variant color image upload
            if (req.files && req.files[`variants[${index}][colorImage]`]) {
              const variantImageFile =
                req.files[`variants[${index}][colorImage]`][0];
              if (variantImageFile) {
                const uploadedVariantImage = await uploadSingleImage(
                  variantImageFile
                );
                colorImage = {
                  public_id: uploadedVariantImage.public_id,
                  secure_url: uploadedVariantImage.secure_url,
                };
              }
            }

            return {
              color: variant.color,
              colorImage,
              sizes: variant.sizes.map((size) => ({
                size: size.size,
                stock: size.stock || 0,
              })),
            };
          })
        );
      } catch (error) {
        console.error("Error parsing or processing variants:", error);
        return res.status(400).json({ error: "Invalid variants data" });
      }
    }

    // Generate tags
    const autoGeneratedTags = [
      ...title.split(" "),
      brand,
      categoryExists.name,
      subcategoryExists.name,
    ].filter(Boolean);
    const tags = [
      ...new Set(autoGeneratedTags.map((tag) => tag.toLowerCase())),
    ];

    // Create Product
    const newProduct = await Product.create({
      title,
      slug,
      description,
      price,
      discount,
      discountedPrice,
      brand,
      category,
      subcategory,
      images: mainImages,
      variants: processedVariants,
      isFeatured,
      tags,
    });

    res
      .status(201)
      .json({ message: "Product created successfully", product: newProduct });
  } catch (error) {
    console.error("Error in createProduct:", error);
    res.status(500).json({ error: "Server error. Please try again later." });
  } finally {
    if (req.files) cleanUpFiles(req.files); // Clean up temp files
  }
};

// Name : Get product by Id
// Route : http://localhost:8000/product/:id
// Method : GET
// Access : Public
export const getProductController = async (req, res) => {
  try {
    const { id } = req.params;
    const getProductById = await Product.findById(id);
    if (!getProductById) {
      return res.status(404).json({ error: "Product not found" });
    }
    res.status(200).json({ getProductById });
  } catch (error) {
    console.log(error);
  }
};

// Name : Get products
// Route : http://localhost:8000/product
// Method : GET
// Access : Public
export const getProductsController = async (req, res) => {
  try {
    const resultPerPage = parseInt(req.query.limit) || 10;

    // First get categories and subcategories to populate filter options
    const categories = await Category.find().select("name _id");
    const subcategories = await SubCategory.find().select("name _id category");

    const apiFeatures = new ApiFeatures(
      Product.find()
        .populate("category", "name")
        .populate("subcategory", "name"),
      req.query
    )
      .search()
      .filter()
      .sort()
      .paginate();

    const products = await apiFeatures.query;
    const totalCount = await apiFeatures.getTotalCount();
    const totalPages = Math.ceil(totalCount / resultPerPage);

    res.status(200).json({
      success: true,
      totalProducts: totalCount,
      totalPages,
      products: products.length === 0 ? [] : products,
      resultPerPage,
      currentPage: parseInt(req.query.page) || 1,
      categories, // Include categories in response
      subcategories, // Include subcategories in response
      message:
        products.length === 0
          ? "No products found"
          : "Products retrieved successfully",
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, message: "Internal Server Error" });
  }
};

// Name : Get product by subCategoryId
// Route : http://localhost:8000/product/:subcategoryId
// Method : GET
// Access : Public
export const getProductsBySubCategoryId = async (req, res) => {
  try {
    const { subCategoryId } = req.params;

    // Find products linked to the given subCategoryId
    const products = await Product.find({ subCategory: subCategoryId })
      .populate("subCategory", "name")
      .populate("category", "name");

    if (products.length === 0) {
      return res
        .status(200)
        .json({ message: "No products found in this subcategory" });
    }
    res.status(200).json({ products });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

// Name : Update product by Id
// Route : http://localhost:8000/product/:id
// Method : PUT
// Access : Private
export const updateProductController = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      title,
      description,
      price,
      discount,
      brand,
      category,
      subcategory,
      isFeatured,
    } = req.body;

    // Find the existing product
    const existingProduct = await Product.findById(id);
    if (!existingProduct) {
      return res.status(404).json({ error: "Product not found" });
    }

    // Validate required fields
    if (
      !title ||
      !description ||
      !price ||
      !brand ||
      !category ||
      !subcategory
    ) {
      return res
        .status(400)
        .json({ error: "Please provide all required fields" });
    }

    // Check if the new title already exists (excluding the current product)
    const existName = await Product.findOne({ title, _id: { $ne: id } });
    if (existName) {
      return res.status(400).json({ error: "Product title already exists" });
    }

    // Generate slug
    const slug = slugify(title, { lower: true, strict: true });

    // Validate category and subcategory
    const categoryExists = await Category.findById(category);
    const subcategoryExists = await SubCategory.findById(subcategory);
    if (!categoryExists || !subcategoryExists) {
      return res.status(400).json({ error: "Invalid category or subcategory" });
    }

    // Calculate discounted price
    const discountedPrice = discount ? price - (price * discount) / 100 : price;

    // Delete existing main images from Cloudinary if new images are provided
    if (req.files && req.files["images"]) {
      const existingImageIds = existingProduct.images
        ? existingProduct.images.map((img) => img.public_id).filter(Boolean)
        : [];
      if (existingImageIds.length > 0) {
        await deleteMultipleImages(existingImageIds);
      }
    }

    // Upload new main product images
    let mainImages = existingProduct.images || [];
    if (req.files && req.files["images"]) {
      mainImages = await uploadMultipleImages(req.files["images"]);
    }

    // Handle variants
    let processedVariants = existingProduct.variants || [];
    if (req.body.variants) {
      try {
        const variants = JSON.parse(req.body.variants);

        // Delete existing variant color images from Cloudinary
        if (existingProduct.variants) {
          for (const variant of existingProduct.variants) {
            if (variant.colorImage && variant.colorImage.public_id) {
              await deleteImage(variant.colorImage.public_id);
            }
          }
        }

        processedVariants = await Promise.all(
          variants.map(async (variant, index) => {
            let colorImage = null;

            // Handle variant color image upload
            if (req.files && req.files[`variants[${index}][colorImage]`]) {
              const variantImageFile =
                req.files[`variants[${index}][colorImage]`][0];
              if (variantImageFile) {
                const uploadedVariantImage = await uploadSingleImage(
                  variantImageFile
                );
                colorImage = {
                  public_id: uploadedVariantImage.public_id,
                  secure_url: uploadedVariantImage.secure_url,
                };
              }
            }

            return {
              color: variant.color,
              colorImage,
              sizes: variant.sizes.map((size) => ({
                size: size.size,
                stock: size.stock || 0,
              })),
            };
          })
        );
      } catch (error) {
        console.error("Error parsing or processing variants:", error);
        return res.status(400).json({ error: "Invalid variants data" });
      }
    }

    // Generate tags
    const autoGeneratedTags = [
      ...title.split(" "),
      brand,
      categoryExists.name,
      subcategoryExists.name,
    ].filter(Boolean);
    const tags = [
      ...new Set(autoGeneratedTags.map((tag) => tag.toLowerCase())),
    ];

    // Update Product
    const updatedProduct = await Product.findByIdAndUpdate(
      id,
      {
        title,
        slug,
        description,
        price,
        discount,
        discountedPrice,
        brand,
        category,
        subcategory,
        images: mainImages,
        variants: processedVariants,
        isFeatured,
        tags,
      },
      { new: true }
    );

    res.status(200).json({
      message: "Product updated successfully",
      product: updatedProduct,
    });
  } catch (error) {
    console.log(error);
  } finally {
    if (req.files) cleanUpFiles(req.files); // Clean up temp files
  }
};

// Name : Delete product by Id
// Route : http://localhost:8000/product/:id
// Method : DELETE
// Access : Private
export const deleteProductController = async (req, res) => {
  try {
    const { id } = req.params;

    // Find the existing product
    const existingProduct = await Product.findById(id);
    if (!existingProduct) {
      return res.status(404).json({ error: "Product not found" });
    }

    // Delete main images from Cloudinary (if they exist)
    if (existingProduct.images && existingProduct.images.length > 0) {
      const existingImageIds = existingProduct.images
        .map((img) => img.public_id)
        .filter(Boolean);
      if (existingImageIds.length > 0) {
        await deleteMultipleImages(existingImageIds);
      }
    }

    // Delete variant color images from Cloudinary (if they exist)
    if (existingProduct.variants && existingProduct.variants.length > 0) {
      for (const variant of existingProduct.variants) {
        if (variant.colorImage && variant.colorImage.public_id) {
          await deleteImage(variant.colorImage.public_id);
        }
      }
    }
    // Delete the product from the database
    await Product.findByIdAndDelete(id);

    res.status(200).json({ message: "Product deleted successfully" });
  } catch (error) {
    console.error("Error in deleteProduct:", error);
    res.status(500).json({ error: "Server error. Please try again later." });
  }
};
